---
layout: post
current: post
cover: assets/built/images/bus.jpg
navigation: True
title: SQL
date: 2021-10-19 00:00:00
tags: [SQL]
class: post-template
subclass: 'post'
author: Chanji
---

## &#10041; MySQL DB 부분에 대해서 학습합니다.

{% include SQL-table-of-contents.html %}

### &#10045; MySQL 단축키
- `Ctrl + Enter`: 세미클론(;)으로 분리된 쿼리 실행
- `Ctrl + Shift + Enter`: 마우스로 선택된 분리된 쿼리를 여러개 실행
- `Ctrl + T`: 새로운 쿼리 에디터 열기
- `Ctrl + Shift + O`: 저장된 스크립트파일(*.sql) 열기
- `Ctrl + B`: 쿼리 정렬
- `Ctrl + R`: Reverse Engineer DATABASE
- `Ctrl + /`: 쿼리 주석

### &#10045; 데이터베이스 생성하기

쿼리창에 작성하자
~~~sql
CREATE DATABASE copang_main
~~~

### &#10045; sys 데이터 베이스
- MySQL 서버의 성능 관련 정보들을 갖고 있는 데이터베이스
- DBMS가 성능 저하 없이 효율적으로 작업을 처리하고 있는 지 체크

### &#10045; 데이터 베이스 테이블 생성하기

~~~sql
USE copang_main; -- 특정 데이터베이스 사용

CREATE TABLE `member` ( -- 데이터베이스에 테이블 생성
  `id` int,
  `email` text,
  `age` int,
  `gender` text,
  `height` double,
  `weight` double,
  `birthday` date,
  `sign_up_day` date,
  `address` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

INSERT INTO `member` (`id`, `email`, `age`, `gender`, `height`, `weight`, `birthday`, `sign_up_day`, `address`) VALUES 
(1,'codeit@naver.com',28,'m',178.2,70,'1992-01-03','2019-03-26','서울특별시 중구 삼일대로 343 103호'),
(2,'korin02@google.com',29,'m',165.7,67.3,'1992-08-13','2019-02-27','서울특별시 중구 세종대로 110 502호'),
(3,'cowboy@codeit.kr',31,'m',NULL,70.2,'1990-01-03','2019-01-05','경기도 고양시 일산서구 고양대로 633 204동 203호'),
(4,'get_flower@naver.com',-10,'f',183.5,72,'1975-03-12','2018-11-29',NULL) -- 테이블에 값 삽입
~~~

### &#10045; 생성된 테이블 살펴보기

> 데이터 타입  
> `INT` : 정수형  
> `DOUBLE` : 실수형  
> `TEXT` : 문자형


### &#10045; Primary Key 설정하기
- `primary key` : 테이블에서 하나의 row를 고유하게 식별할 수 있도록 해주는 column
- `Not Null` : 이 컬럼에는 반드시 어떤 값이 들어있어야 한다.
- `Auto Increment` : row가 추가될 때마다 id 컬럼에 이전보다 1이 더 큰 정수를 자동으로 넣어주는 기능
- 날짜 관련 타입은 DATE 타입으로 설정하자

### &#10045; 데이터 조회의 핵심, SELECT와 WHERE

~~~sql
SELECT email, age FROM copang_main.member;
SELECT * FROM copang_main.member;
SELECT * FROM copang_main.member where email = 'taehos@hanmail.net'; -- 이메일 주소가 같은 row 조회
~~~

### &#10045; SQL 작성 형식에 관한 이야기
- SQL 문 끝에는 항상 세미콜론을 써줘야합니다.
- SQL 문 안에는 공백이나 개행 등을 자유롭게 넣을 수 있습니다.
- SQL 문의 대소문자 구분 문자(예약어는 대문자)
- 데이터베이스 이름과 테이블 이름을 함께 쓰자

### &#10045; 조건을 나타내는 다양한 방법
~~~sql
SELECT * FROM copang_main.member WHERE age BETWEEN 30 AND 39;

SELECT * FROM copang_main.member WHERE age NOT BETWEEN 30 AND 39;

SELECT * FROM copang_main.member WHERE sign_up_day > '2019-01-01';

SELECT * FROM copang_main.member WHERE sign_up_day BETWEEN '2018-01-01' AND '2018-12-31';
~~~

### &#10045; 문자열 패턴 매칭 조건

~~~sql
SELECT * FROM copang_main.member WHERE address LIKE '서울%';

SELECT * FROM copang_main.member WHERE address LIKE '%고양시%';

SELECT * FROM copang_main.member WHERE address LIKE '%103호';
~~~

### &#10045; 그밖에 알아야할 조건 표현식
1. 같지 않음(!=, <>)
2. 이 중에 있는~ (IN) 연속된 범위가 아님
3. 한 글자를 나타내는_

~~~sql
SELECT * FROM copang_main.member WHERE gender !='m';

SELECT * FROM copang_main.member WHERE age IN(20, 30);

SELECT * FROM copang_main.member WHERE email LIKE 'c_____@%';
~~~

### &#10045; DATA 데이터 타입 관련 함수

- 연도, 월, 일 추출하기
  * 1992년에 태어난 회원들만 조회하기
  ~~~sql
  SELECT * FROM copang_main.member WHERE YEAR(birthday) = '1992';
  ~~~
  * 여름(6, 7, 8월)에 가입한 회원들만 조회하기
  ~~~sql
  SELECT * FROM copang_main.member WHERE MONTH(sign_up_day) IN (6,7,8);
  ~~~
  * 각 달의 후반부(15일~31일)에 가입했던 회원들만 조회하기
  ~~~sql
  SELECT * FROM copang_main.member WHERE DAYOFMONTH(sign_up_day) BETWEEN 15 AND 31;
  ~~~

- 날짜 간의 차이 구하기  

~~~sql
SELECT email, sign_up_day, DATEDIFF(sign_up_day, '2019-01-01') FROM copang_main.member;

SELECT email, sign_up_day, CURDATE(), DATEDIFF(sign_up_day, CURDATE()) FROM copang_main.member;

SELECT email, sign_up_day, DATEDIFF(sign_up_day, birthday) /365 FROM copang_main.member;
~~~

- 날짜 더하기 빼기  

~~~sql
SELECT email, sign_up_day, DATE_ADD(sign_up_day, INTERVAL 300 DAY) FROM copang_main.member;

SELECT email, sign_up_day, DATE_SUB(sign_up_day, INTERVAL 250 DAY) FROM copang_main.member;
~~~
- UNIX Timestamp 값(1970년 1월 1일 기준으로 몇초가 지났는지)


~~~sql
SELECT email, sign_up_day, UNIX_TIMESTAMP(sign_up_day) FROM copang_main.member;

SELECT email, sign_up_day, FROM_UNIXTIME(UNIX_TIMESTAMP(sign_up_day)) FROM copang_main.member;
~~~

### &#10045; 여러 개의 조건 걸기
~~~sql
SELECT * FROM copang_main.member 
WHERE gender = 'm' 
	AND address LIKE '서울%' 
    AND age BETWEEN 25 AND 29;

SELECT * FROM copang_main.member 
WHERE MONTH(sign_up_day) BETWEEN 3 AND 5 
	OR MONTH(sign_up_day) BETWEEN 9 AND 11;

SELECT * FROM copang_main.member
WHERE (gender = 'm' AND height >= 180) 
	OR (gender = 'f' AND height >= 170);
~~~

### &#10045;OR를 사용할 때의 주의사항
1. OR를 사용할 때의 주의사항
> SELECT * FROM copang_main.member WHERE id = 1 OR id =2;  
> SELECT * FROM copang_main.member WHERE id = 1 OR 2;  
> `위의 두 식이 의미하는 바는 틀리다`  
> **MySQL에서는 0을 False, 0 이외의 숫자는 모두 True**

2. AND와 OR 간의 우선순위
   - AND가 OR보다 우선순위가 높다는 사실
   - 아래의 두 식이 의미하는 바가 틀리다


~~~sql
SELECT * FROM copang_main.member 
WHERE gender = 'f' OR age < 30 AND height > 180

SELECT * FROM copang_main.member 
WHERE (gender = 'f' OR age < 30) AND height > 180
~~~ 

### &#10045; 문자열 패턴 매칭 조건을 사용할 때 주의할 점
1. 이스케이핑(escaping) 문제
> 백슬래시(\) + 표현식(%, /, ', ")로 입력시 문자열로 인식  
> 표현식만 사용하면 문자열로 인식되지 않는다.

2. 대소문자 구분 문제
> 문자열의 대소문자 구분할려면 BINARY를 붙이자


~~~sql
SELECT * FROM copang_main.member WHERE address LIKE BINARY '%g%';
SELECT * FROM copang_main.member WHERE address LIKE BINARY '%G%';
~~~

### &#10045; 데이터 정렬해서 보기
~~~sql
SELECT * FROM copang_main.member
ORDER BY height;

SELECT * FROM copang_main.member
ORDER BY height ASC;

SELECT * FROM copang_main.member
ORDER BY height DESC;

SELECT * FROM copang_main.member
WHERE gender = 'm'
	AND weight >= 70
ORDER BY height ASC;

SELECT sign_up_day, email FROM copang_main.member
ORDER BY YEAR(sign_up_day) DESC, email ASC;
~~~

### &#10045; 각절의 작성 순서를 꼭 지켜주세요
~~~sql
SELECT
    [ALL | DISTINCT | DISTINCTROW ]
    [HIGH_PRIORITY]
    [STRAIGHT_JOIN]
    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
    [SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    select_expr [, select_expr] ...
    [into_option]
    [FROM table_references
      [PARTITION partition_list]]
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}, ... [WITH ROLLUP]]
    [HAVING where_condition]
    [WINDOW window_name AS (window_spec)
        [, window_name AS (window_spec)] ...]
    [ORDER BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
    [into_option]
    [FOR {UPDATE | SHARE}
        [OF tbl_name [, tbl_name] ...]
        [NOWAIT | SKIP LOCKED]
      | LOCK IN SHARE MODE]
    [into_option]

into_option: {
    INTO OUTFILE 'file_name'
        [CHARACTER SET charset_name]
        export_options
  | INTO DUMPFILE 'file_name'
  | INTO var_name [, var_name] ...
}
~~~
> SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> WINDOW -> ORDER BY -> LIMIT -> FOR  
> SQL문은 위의 순서를 지켜주어야 한다.

### &#10045; 정렬할 때 주의할 점
- 정렬할 때 타입이 숫자형(INT), 문자형(TEXT) 인지 인지하고 정렬해야한다.
- 타입이 맞지 않을 때는 CAST() 함수를 사용하여 일시적 타입변환한 것을 기준을 정렬한다.

~~~sql
SELECT * FROM FOR_TEST.ordering_test ORDER BY data ASC;

SELECT * FROM FOR_TEST.ordering_test ORDER BY data ASC;

SELECT * FROM FOR_TEST.ordering_test ORDER BY CAST(data AS signed) ASC;
~~~

### &#10045; 데이터 일부만 추려보기
- row는 0번째부터 카운터 된다.

~~~sql
SELECT * FROM copang_main.member
ORDER BY sign_up_day DESC
LIMIT 10; -- 10개 추려내기

SELECT * FROM copang_main.member
ORDER BY sign_up_day DESC
LIMIT 8, 2; -- 8번째 부터 2개 추려내기
~~~

### &#10045; LIMIT과 Pagination(심화)

~~~
1페이지 : SELECT * FROM db.search_result ~ ORDER BY registration_date DESC LIMIT 0, 10

2페이지 : SELECT * FROM db.search_result ~ ORDER BY registration_date DESC LIMIT 10, 10

3페이지 : SELECT * FROM db.search_result ~ ORDER BY registration_date DESC LIMIT 20, 10

4페이지 : SELECT * FROM db.search_result ~ ORDER BY registration_date DESC LIMIT 30, 10
~~~
- 우리가 새로운 페이지를 누르면 그때마다, 10개의 새로운 내용들을 로드(load)할 텐데요. 이런 걸 전문 용어로 '페이지네이션(Pagination)'이라고 합니다.
- 전체 결과를 한번에 로드하는 게 아니라 이렇게 페이지 단위로 쪼개서 그때그때 요청이 있을 때마다 부분 결과를 조금씩 로드하는 방식을 말하죠. 

### &#10045; 데이터의 특성 구하기
- 행의 개수 구하기(COUNT())
- 최댓값 구하기(MAX())
- 최솟값 구하기(MIN())
- 평균값 구하기(AVG())
- Null 인 행렬은 포함하지 않는다.

~~~sql
SELECT COUNT(*) FROM copang_main.member;

SELECT COUNT(email) FROM copang_main.member;

SELECT COUNT(address) FROM copang_main.member;

SELECT MAX(height) FROM copang_main.member;

SELECT MIN(weight) FROM copang_main.member;

SELECT AVG(weight) FROM copang_main.member;
~~~

### &#10045; NULL을 다루는 방법

~~~sql
-- address colum에 Null 있는 부분만 조회
SELECT * FROM copang_main.member WHERE address IS NULL;

-- address colum에 Null 있지 않은 부분만 조회
SELECT * FROM copang_main.member WHERE address IS NOT NULL;

-- height, weight, address colum에 Null 있는 부분만 조회
SELECT * FROM copang_main.member 
WHERE address IS NULL
	OR weight IS NULL
    OR address IS NULL;

-- COALESCE()를 사용하여 값이 null일때 다른 값으로 변경
SELECT
	COALESCE(height, '####'),
    COALESCE(weight, '---'),
    COALESCE(address, '@@@')
FROM copang_main.member;
~~~

### &#10045; NULL에 관해 알아야하는 사실
* IS NULL과 = NULL 은 다르다.  
* NULL은 어떤 값이 아니기 때문에 애초에 등호(=)를 사용해서 어떤 값과 비교할 수 있는 대상이 아닙니다.   
* 반드시 IS NULL, IS NOT NULL로 사용하여야 한다.  
* NULL에는 어떤 연산을 해도 결국 NULL이다.

### &#10045; 이상한 값을 제외

~~~sql
-- 이상값 제외하고 평균 구하기
SELECT AVG(age) FROM copang_main.member WHERE age BETWEEN 5 AND 100;

-- 정상인 주소들만 추출
SELECT * FROM copang_main.member WHERE address LIKE '%호';
~~~


### &#10045; 컬럼끼리 계산하기

~~~sql
-- BMI 계산하여 추가하기
-- 계산하는 값 중에 Null 이 있으면 계산된 것도 NUll
SELECT email, height, weight, weight / ((height/100)*(height/100)) AS BMI
FROM copang_main.member;
~~~

### &#10045; 컬럼에 alias 붙이기
~~~sql
-- Alias 추가하기
SELECT 
	email, 
    height AS 키, 
    weight AS 몸무게, 
    weight / ((height/100)*(height/100)) AS BMI
FROM copang_main.member;

-- AS를 안붙혀도 적용되지만 붙이는 것이 좋다.
SELECT 
	email, 
    height 키, 
    weight 몸무게, 
    weight / ((height/100)*(height/100)) BMI
FROM copang_main.member;

-- CONCAT 함수를 사용하여서 값과 문자를 연결 시킬수 있다.
SELECT 
	email, 
    CONCAT(height, 'cm', ', ' , weight, 'kg') AS '키와 몸무게',
    weight / ((height/100)*(height/100)) BMI
FROM copang_main.member;
~~~


### &#10045; 컬럼의 값 변환해서 보기

~~~sql
-- CASE 문을 통해서 새로운 컬럼을 만들어서 표시하였음
-- CASE 문으로 만든 컬럼을 기준으로 정렬하였음
SELECT 
	email, 
    height AS 키, 
    weight AS 몸무게, 
    weight / ((height/100)*(height/100)) AS BMI,
(CASE
	WHEN weight IS NULL OR height is NULL THEN '비만 여부 알 수 없음'
    WHEN weight / ((height/100)*(height/100)) >= 25 THEN '과체중 또는 비만'
    WHEN weight / ((height/100)*(height/100)) >= 18.5 AND weight / ((height/100)*(height/100)) < 25 THEN '정상'
    ELSE '저체중'
END) AS obesity_check
FROM copang_main.member
ORDER BY obesity_check ASC;


-- CASE 문으로 age 29, 30일때 변경
SELECT
	email,
    (CASE age
		WHEN 29 THEN '스물 아홉 살'
        WHEN 30 THEN '서른 살'
        ELSE age
	END) AS 나이
FROM copang_main.member;
~~~

### &#10045; NULL을 다른 값으로 변환하는 다양한 함수
* COALESCE 함수

~~~sql
SELECT COALESCE(height, 'N/A')
FROM copang_main.member;

-- height, weight 둘다 Null 경우만 대체된다.
SELECT COALESCE(height, weight * 2,3,'N/A')
FROM copang_main.member;
~~~

* IFNULL 함수

~~~sql
--  height 컬럼이 NULL이면 'N/A'를 출력하고, NULL이 아니면 height 컬럼의 값 출력
SELECT IFNULL(height, 'N/A')
FROM copang_main.member;
~~~

* IF 함수

~~~sql
--  IF 함수는 첫번째 인자 True라면 두 번째 인자를 리턴하고, False라면 세 번째 인자를 리턴합니다.
SELECT IF(height IS NOT NULL, height,'N/A')
FROM copang_main.member;
~~~

* CASE 함수

~~~sql
--  CASE 함수로도 NULL을 적절한 값으로 변환해서 나타낼 수 있습니다. 
SELECT
	CASE
		WHEN height IS NOT NULL THEN height
        ELSE 'N/A'
	END
FROM copang_main.member;
~~~

### &#10045; alias를 붙이고 바로 쓸 수 없는 이유

* 띄어쓰기(스페이스)가 포함된 aliase에는 따옴표를 붙여줘야 합니다.
* SELECT 절에서 설정한 alias를 바로 사용할 수 없습니다.

### &#10045; 고유값만 보기(DISTINCT 함수 이용)

~~~sql
-- 고유한 값들 확인(중복되는 값 제외)
SELECT DISTINCT(gender) FROM copang_main.member;

-- 특정 문자 기준으로 고유값(앞에 문자 2개 추출)
SELECT DISTINCT(SUBSTRING(address, 1, 2)) FROM copang_main.member;

-- 고유값의 개수 구하기(COUNT 함수 활용)
SELECT COUNT(DISTINCT(gender)) FROM copang_main.member;
SELECT COUNT(DISTINCT(SUBSTRING(address, 1, 2))) FROM copang_main.member;
~~~

### &#10045; 문자열에 관한 함수들

~~~sql
-- LENGTH 함수: 문자의 길이를 구해준다.
SELECT *, LENGTH(address) AS address_len FROM copang_main.member;

-- UPPER 함수: 문자열을 모두 대문자로 바꿔준다.
SELECT email, UPPER(email) AS upper_email FROM copang_main.member;

-- LOWER 함수: 문자열을 모두 소문자로 바꿔준다.
SELECT email, LOWER(email) AS lower_email FROM copang_main.member;

-- LPAD 함수: 왼쪽 채우기
SELECT email, LPAD(age, 10, '0') FROM copang_main.member;

-- RPAD 함수: 오른쪽 채우기
SELECT email, RPAD(age, 10, '!') FROM copang_main.member;

-- TRIM 함수: 양쪽 공백 제거
SELECT TRIM(address) FROM copang_main.member;

-- LTRIM 함수: 왼쪽 공백 제거
SELECT LTRIM(address) FROM copang_main.member;

-- RTRIM  함수: 오른쪽 공백 제거
SELECT RTRIM(address) FROM copang_main.member;
~~~

### &#10045; 그루핑해서 보기

~~~sql
-- GROUP BY를 사용하면 각각의 row는 여러개의 row를 나타내게 된다.
-- 함수는 그룹별로 작동하게 된다.
-- 테이블 전체가 아니라 각 그룹에 대해서 함수가 작동하게 된다.
SELECT 
	gender, 
    COUNT(*), 
    AVG(height),
    MIN(weight)
FROM copang_main.member 
GROUP BY gender;
~~~

~~~sql
-- GROUP BY를 통해서 그룹에 대한 기준을 정할 수 있다.
-- 그룹핑 기준은 2개이상 이여도 된다.
-- 더 세부적으로 그룹을 나눌 수 있다.
SELECT 
	SUBSTRING(address, 1, 2) AS region,
	gender, 
    COUNT(*), 
    AVG(height),
    MIN(weight)
FROM copang_main.member 
GROUP BY 
	SUBSTRING(address, 1, 2),
	gender;
~~~

~~~sql
-- HAVING 통해서 선별하여 조회할 수 있다.
-- GROUP BY 이후에는 WHERE 사용하지 못하고 HAVING을 사용하여서 조회해야한다.
SELECT 
	SUBSTRING(address, 1, 2) AS region,
	gender, 
    COUNT(*), 
    AVG(height),
    MIN(weight)
FROM copang_main.member 
GROUP BY 
	SUBSTRING(address, 1, 2),
	gender
HAVING 
	region = '서울'
    AND gender = 'm';

-- HAVING 뒤에 ORDER BY 사용해서 정렬 가능하다.    
SELECT 
	SUBSTRING(address, 1, 2) AS region,
	gender, 
    COUNT(*), 
    AVG(height),
    MIN(weight)
FROM copang_main.member 
GROUP BY 
	SUBSTRING(address, 1, 2),
	gender
HAVING 
	region IS NOT NULL
    AND region != '어린'
ORDER BY
	region ASC,
    gender DESC;
~~~

~~~sql
-- WITH ROLLUP을 사용하면 부분 총계 ROW를 얻을 수 있다.
-- GROUP BY 의 순서에 따라서 기준이 틀려져서 값이 다르게 나올 수도 있다.
-- GROUPING 함수를 사용하여서 NULL 값이 WITH ROLLUP 의해서 나타나는 NULL 인지 판단할 수 있다.
SELECT 
	SUBSTRING(address, 1, 2) AS region,
	gender, 
    COUNT(*), 
    AVG(height),
    MIN(weight),
    GROUPING(gender)
FROM copang_main.member 
GROUP BY 
	SUBSTRING(address, 1, 2),
	gender
WITH ROLLUP
HAVING 
	region IS NOT NULL
    AND region != '어린'
ORDER BY
	region ASC,
    gender DESC;
~~~

### &#10045; SELECT 문의 실행 순서

~~~
#  작성순서
1. SELECT
2. FROM
3. WHERE
4. GROUP BY
5. HAVING
6. ORDER BY
7. LIMIT

#  실행순서
1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY
7. LIMIT
~~~

### &#10045; Foreign Key 개념
- 현재 테이블에서 다른 테이블을 식별할 수 있는 요소
- 다른 테이블에 없는 값을 현재 테이블에 추가 되는 것을 방지
- 참조하는 테이블에서 Foreign Key 설정

### &#10045; 다른 종류의 테이블 조인하기

~~~sql
-- LEFT OUTER JOIN 왼쪽테이블 기준으로 stock 테이블을 합쳐라
-- ON을 기준을 왼쪽으로 합친다.
-- 조회된 값을 보면 id컬럼과 item_id컬럼은 같다.
-- item_id가 null 값이 생긴다.
SELECT
	item.id,
    item.name,
    stock.item_id,
    stock.inventory_count
FROM item LEFT OUTER JOIN stock
ON item.id = stock.item_id;

-- RIGHT OUTER JOIN 오른쪽 테이블 기준으로 합친다.
SELECT
	item.id,
    item.name,
    stock.item_id,
    stock.inventory_count
FROM item RIGHT OUTER JOIN stock
ON item.id = stock.item_id;
~~~

~~~sql
-- 테이블도 alias 가능하다. FROM이 제일 먼저 실행
-- 테이블 alias 할때 테이블 사용한 모든 값을 alias로 변경해야한다.
SELECT
	i.id,
    i.name,
    s.item_id,
    s.inventory_count
FROM item AS i LEFT OUTER JOIN stock AS s
ON i.id = s.item_id;
~~~

~~~sql
-- INNER JOIN 두 테이블 간에 교집합
-- Null 인값이 나타나지 않는다.
-- Foreign Key 설정되어 있으므로 OUTER JOIN(LEFT 또는 RIGHT)의 결과와 INNER JOIN의 결과가 같을 수 있다
SELECT
	i.id,
    i.name,
    s.item_id,
    s.inventory_count
FROM item AS i INNER JOIN stock AS s
ON i.id = s.item_id;
~~~

### &#10045; 결합 연산과 집합 연산
* 결합 연산
  - LEFT OUTER JOIN
  - RIGHT OUTER JOIN
  - INNER JOIN

* 집합 연산
  - A ∩ B (INTERSECT 연산자 사용)
  - A - B (MINUS 연산자 또는 EXCEPT 연산자 사용)
  - B - A (MINUS 연산자 또는 EXCEPT 연산자 사용)
  - A U B (UNION 연산자 사용)(MySQL에서는 이것만 가능)
~~~sql
-- A ∩ B
SELECT * FROM member_A 
INTERSECT 
SELECT * FROM member_B;

-- A - B
SELECT * FROM member_A 
MINUS
SELECT * FROM member_B;

-- B - A
SELECT * FROM member_B
MINUS
SELECT * FROM member_A;

-- A U B(MySQL에서는 이것만 가능)
SELECT * FROM member_A
UNION
SELECT * FROM member_B;
~~~

### &#10045; 같은 종류의 테이블 조인하기

~~~sql
-- LEFT OUTER JOIN을 통해서 old 테이블을 기준으로 new 테이블에 없는 값을 조회할 수 있다.
SELECT
	old.id AS old_id,
    old.name AS old_name,
    new.id AS new_id,
    new.name AS new_name
FROM item AS old LEFT OUTER JOIN item_new AS new
ON old.id = new.id
WHERE new.id IS NULL;

-- RIGHT OUTER JOIN을 통해서 new 테이블을 기준으로 old 테이블에 없는 값을 조회할 수 있다.
SELECT
	old.id AS old_id,
    old.name AS old_name,
    new.id AS new_id,
    new.name AS new_name
FROM item AS old RIGHT OUTER JOIN item_new AS new
ON old.id = new.id
WHERE old.id IS NULL;

--  JOIN을 통해서 new 테이블과 old 테이블의 공통된 부분을 조회할 수 있습니다.
SELECT
	old.id AS old_id,
    old.name AS old_name,
    new.id AS new_id,
    new.name AS new_name
FROM item AS old INNER JOIN item_new AS new
ON old.id = new.id;

-- UNION 두 조회 결과를 합쳐준다.
SELECT * FROM item
UNION
SELECT * FROM item_new;
~~~

~~~sql
-- ON 대신해서 두 테이블에 컬럼이름이 같은 경우 USING을 사용한다.
SELECT
	old.id AS old_id,
    old.name AS old_name,
    new.id AS new_id,
    new.name AS new_name
FROM item AS old INNER JOIN item_new AS new
USING(id);
~~~

### &#10045; UNION 더 알아 보기
- UNION 두 테이블 합친 후에 중복을 제거한다.
- UNION ALL 두 테이블 합친 후에 중복을 제거하지 않는다.

### &#10045; 세 테이블 조인한 후 의미있는 데이터 추출

~~~sql
-- LEFT OUTER JOIN 조인이 순서대로 실행된다.
-- 세 개의 테이블 합치기
-- 그 이후 유의미한 컬럼 추출
-- GROUP BY 그룹을 나눈 이후 AVG(star) 평균값 도출
-- 테이블 예약어와 같은면 백틱(`)을 붙혀주자
-- 평균, 개수를 구해서 사용하자
-- 여성 인기 상품
SELECT 
    i.id, i.name, AVG(star), COUNT(*)
FROM
    item AS i
        LEFT OUTER JOIN
    review AS r ON r.item_id = i.id
        LEFT OUTER JOIN
    `member` AS m ON r.mem_id = m.id
WHERE
    m.gender = 'f'
GROUP BY i.id , i.name
HAVING COUNT(*) > 1
ORDER BY AVG(star) DESC , COUNT(*) DESC;

-- 남성회원이 좋게 평가한 것들
SELECT 
    i.id, i.name, AVG(star), COUNT(*)
FROM
    item AS i
        LEFT OUTER JOIN
    review AS r ON r.item_id = i.id
        LEFT OUTER JOIN
    `member` AS m ON r.mem_id = m.id
WHERE
    m.gender = 'm'
GROUP BY i.id , i.name
HAVING COUNT(*) > 1
ORDER BY AVG(star) DESC , COUNT(*) DESC;

-- 불만 있는 제품 comment 조회
SELECT * FROM review WHERE item_id = 2;
~~~


### &#10045; 다른 종류의 조인들

1. NATURAL JOIN : ON 이 필요가 없이 자동으로 기준을 설정해준다.
2. CROSS JOIN : 한 테이블의 하나의 row에 다른 테이블의 모든 row들을 매칭통해서 두 테이블의 row들의 모든 조합을 보여주는 조인
3. SELF JOIN : 자기 자신과 조인을 하는 경우를 말합니다.(새로운 조인이 아님)
4. FULL OUTER JOIN : UNION ALL과 같이 똑같다. 중복제거할려면 UNION을 사용하자
5. Non-Equi 조인: 동등 조건이 아닌 다른 조건으로 사용

~~~sql
-- NATURAL JOIN
SELECT p.id, p.player_name, p.team_name, t.team_name, t.region
FROM player AS p NATURAL JOIN team AS t;

-- CROSS JOIN
SELECT * FROM member CROSS JOIN stock;

-- SELF JOIN(새로운 조인이 아님)
SELECT *
FROM employee AS e1 LEFT OUTER JOIN employee AS e2
ON e1.boss = e2.id;

-- FULL OUTER JOIN(오라클에서만 사용가능)
SELECT * 
FROM player AS p FULL OUTER JOIN team AS t
ON p.team_name = t.team_name;

-- Non-Equi 조인(새로운 조인이 아님)
SELECT m.email, m.sign_up_day, i.name, i.registration_date
FROM copang_main.member AS m LEFT OUTER JOIN copang_main.item AS i 
ON m.sign_up_day < i.registration_date
ORDER BY m.sign_up_day ASC;
~~~

### &#10045; 서브쿼리란?

- SQL 문 안에 '부품'처럼 들어가는 SELECT 문

~~~sql
-- 쿼리문 안에 쿼리문 설정(서브쿼리)
-- 전체 sql문에서 일부의 요소
-- 서브쿼리 사용시 () 필수
SELECT 
    i.id, i.name, AVG(star) AS avg_star
FROM
    item AS i
        LEFT OUTER JOIN
    review AS r ON r.item_id = i.id
GROUP BY i.id , i.name
HAVING avg_star < (SELECT AVG(star) FROM review)
ORDER BY avg_star DESC;
~~~

~~~sql
-- SELECT 절에 있는 서브쿼리
-- 특정 컬럼의 특징을 찾아주는 서브쿼리를 많이 사용한다.
SELECT 
    id, name, price,
    (SELECT MAX(price) FROM item) AS max_price,
    (SELECT AVG(price) FROM item) AS avg_price 
FROM
    copang_main.item;
~~~

~~~sql
-- WHERE절에서 서브 쿼리
-- 특정 컬럼의 특징을 찾아주는 서브쿼리를 많이 사용한다.
-- 서브쿼리는 alias 값 활용하기 어렵다.
SELECT 
    id, name, price,
    (SELECT MAX(price) FROM item) AS max_price,
    (SELECT AVG(price) FROM item) AS avg_price 
FROM
    copang_main.item
WHERE price = (SELECT MIN(price) FROM item);
~~~

~~~sql
-- JOIN을 이용하여서 조회 가능
SELECT 
    *, COUNT(*)
FROM
    item AS i
        LEFT OUTER JOIN
    review AS r ON i.id = r.item_id
GROUP BY i.id
HAVING COUNT(*) >= 3;

-- 위에 것과 같은 부분
-- 서브쿼리가 하나이상의 정보를 리턴할 때 사용
SELECT 
    *
FROM
    item
WHERE
    id IN (SELECT 
            item_id
        FROM
            review
        GROUP BY item_id
        HAVING COUNT(*) >= 3);
~~~

### &#10045; 서브쿼리 ANY(SOME), ALL

~~~sql
-- ANY안에 서브쿼리가 리턴하는 값 중에서 view_count 값이 하나라도 크면 조건을 만족한다.
SELECT * FROM FOR_TEST.codeit_theater
    WHERE view_count > ANY(SELECT view_count FROM FOR_TEST.codeit_theater WHERE category = 'ACTION');

-- SOME과 ANY는 같은 역할이다.
SELECT * FROM FOR_TEST.codeit_theater
    WHERE view_count > SOME(SELECT view_count FROM FOR_TEST.codeit_theater WHERE category = 'ACTION');

-- ALL 안에 모든 조건을 만족한다면 해당조건을 만족하게된다.
SELECT * FROM FOR_TEST.codeit_theater
    WHERE view_count > ALL(SELECT view_count FROM FOR_TEST.codeit_theater WHERE category = 'ACTION');
~~~

### &#10045; 서브쿼리의 종류 총정리

~~~sql
-- 단일값을 리턴하는 서브쿼리
SELECT MAX(age) FROM `member`;

-- 하나의 column에 여러 row들이 있는 형태의 결과를 리턴하는 서브쿼리
SELECT SUBSTR(address, 1, 2) FROM `member`;

-- 하나의 테이블 형태의 결과(여러 column, 여러 row)를 리턴하는 서브쿼리
SELECT * FROM `member`;
~~~

~~~sql
-- 비상관 서브쿼리 :  서브쿼리를 독립적으로 실행해도 실행가능한 서브쿼리
SELECT 
    *
FROM
    item
WHERE
    id IN (SELECT 
            item_id
        FROM
            review
        GROUP BY item_id
        HAVING COUNT(*) >= 3);
        
-- 상관 서브쿼리 outer query와 상관 관계가 있는 서브쿼리
-- EXISTS 안 쿼리문이 row가 조회되서 안에 존재하면 최종 결과 바구니에 담깁니다.
-- 해당 작동조건의 review.item_id = item.id 만족할 때 해당 결과가 테이블에 담깁니다.
SELECT 
    *
FROM
    item
WHERE
    NOT EXISTS( SELECT 
            *
        FROM
            review
        WHERE
            review.item_id = item.id);
~~~


~~~sql
-- SELECT문에서 alias 붙이고 바로 쓸수 없지만 서브쿼리를 통해서 해결가능하다
SELECT 
	email, 
    height AS 키, 
    weight AS 몸무게, 
    BMI,
(CASE
	WHEN weight IS NULL OR height is NULL THEN '비만 여부 알 수 없음'
    WHEN BMI >= 25 THEN '과체중 또는 비만'
    WHEN BMI >= 18.5 AND BMI < 25 THEN '정상'
    ELSE '저체중'
END) AS obesity_check
FROM 
(SELECT *, weight / ((height/100)*(height/100)) AS BMI FROM copang_main.member) AS subquery_for_BMI
ORDER BY obesity_check ASC;
~~~

### &#10045; 서브쿼리의 중첩과 그 문제점
- 서브쿼리 안에 서브쿼리를 사용하는 것이 가능하다.
- 서브쿼리 중첩이 가능하다.

~~~sql
SELECT 
    i.id, i.name, AVG(star) AS avg_star, COUNT(*) AS count_star
FROM
    item AS i
        LEFT OUTER JOIN
    review AS r ON r.item_id = i.id
        LEFT OUTER JOIN
    member AS m ON r.mem_id = m.id
WHERE
    m.gender = 'f'
GROUP BY i.id , i.name
HAVING COUNT(*) >= 2
    AND avg_star = (SELECT 
        MAX(avg_star)
    FROM
        (SELECT 
            i.id, i.name, AVG(star) AS avg_star, COUNT(*) AS count_star
        FROM
            item AS i
        LEFT OUTER JOIN review AS r ON r.item_id = i.id
        LEFT OUTER JOIN member AS m ON r.mem_id = m.id
        WHERE
            m.gender = 'f'
        GROUP BY i.id , i.name
        HAVING COUNT(*) >= 2
        ORDER BY AVG(star) DESC , COUNT(*) DESC) AS final)
ORDER BY AVG(star) DESC , COUNT(*) DESC;
~~~

### &#10045; 데이터 분석가의 자산, 뷰
- 조인 등의 작업을 해서 만든 `결과 테이블`이 `가상으로` 저장된 형태
- 복잡한 sql을 짧게 만들어 줄 수 있다.
- 중복된 테이블를 저장하여 사용할 수 있다.
- 자주 사용하는 테이블을 VIEW로 저장하자

~~~sql
-- Views데이터 베이스에 저장(가상 테이블) 
CREATE VIEW three_tables_joined AS
    SELECT 
        i.id, i.name, AVG(star) AS avg_star, COUNT(*) AS count_star
    FROM
        item AS i
            LEFT OUTER JOIN
        review AS r ON r.item_id = i.id
            LEFT OUTER JOIN
        `member` AS m ON r.mem_id = m.id
    WHERE
        m.gender = 'f'
    GROUP BY i.id , i.name
    HAVING COUNT(*) >= 2
    ORDER BY AVG(star) DESC , COUNT(*) DESC;

-- 가상 테이블을 조회
SELECT * FROM three_tables_joined
WHERE avg_star = (
	SELECT MAX(avg_star) FROM copang_main.three_tables_joined
) AND count_star = (
	SELECT MAX(count_star) FROM copang_main.three_tables_joined
);
~~~

* 뷰는 사용자에게 높은 편의성을 제공해줍니다. 
* 각 직무별 데이터 수요에 알맞은, 다양한 구조의 데이터 분석 기반을 구축해둘 수 있습니다. 
* 뷰는 데이터 보안을 제공합니다.

~~~sql
-- 특정 컬럼만 보여주고 싶을 때
CREATE VIEW emp_view AS SELECT id, name, age, department FROM employee;

-- 특정 조건의 정보만 보여주고 싶을 때
CREATE VIEW emp_view2 AS SELECT id, name, age, department FROM employee WHERE department != 'secret';
~~~

### &#10045; 실무에서 첫 번째로 해야할 일
1. 어떤 데이터베이스들이 있는지
2. 각 데이터베이스 안에 어떤 테이블들이 있는지
3. 각 테이블의 컬럼 구조는 어떻게 되는지 
4. 테이블들 간의 Foreign Key 관계는 어떤지

~~~sql
-- 존재하는 데이터 베이스들 파악
SHOW DATABASES;

-- 한 데이터베이스 안의 테이블(뷰도 포함)들 파악
SHOW FULL TABLES IN copang_main;

-- 한 테이블의 컬럼 구조 파악
DESCRIBE item;

-- 데이터 information_schema 데이터 베이스 조회
USE information_schema;
SHOW TABLES;
SELECT user();
SELECT system_user();

-- Foreign Key(외래키) 파악
SELECT
    i.CONSTRAINT_TYPE, i.CONSTRAINT_NAME, i.TABLE_SCHEMA, i.TABLE_NAME
FROM 
    information_schema.TABLE_CONSTRAINTS AS i
    LEFT JOIN information_schema.KEY_COLUMN_USAGE AS k ON i.CONSTRAINT_NAME = k.CONSTRAINT_NAME
WHERE
	i.CONSTRAINT_TYPE = 'FOREIGN KEY';
~~~

### &#10045; 데이터베이스 생성하기

~~~sql
-- 데이터 베이스 생성
CREATE DATABASE course_rating;

-- 같은 이름의 데이터 테이블 존재여부 확인
CREATE DATABASE IF NOT EXISTS course_rating;

-- course_rating 데이터 베이스를 사용하겠다.
USE course_rating;
~~~

### &#10045; 컬럼의 데이터 타입에 관하여

* 정수형 타입
  - TINYINT(SIGNED, UNSIGNED) : -128 ~ 127, 0 ~ 255
  - SMALLINT(SIGNED, UNSIGNED) : -32768 ~ 32767, 0 ~ 65535
  - MEDIUMINT(SIGNED, UNSIGNED) : -8388608 ~ 8388607, 0 ~ 16777215
  - INT(SIGNED, UNSIGNED) : -2147483648 ~ 2147483647, 0 ~ 4294967295
  - BIGINT(SIGNED, UNSIGNED) : -9223372036854775808 ~ 9223372036854775807, 0 ~ 18446744073709551615

* 실수형 타입
  - DECIMAL : 보통 DECIMAL(M, D)의 형식으로 나타냄
  - FLOAT
  - DOUBLE

* 날짜 및 시간 타입(Date and Time Types)
  - DATE :  ’2020-03-26’ 이런 형식의 연, 월, 일 순
  - DATETIME :  ’2020-03-26 09:30:27’ 이런 식으로 연, 월, 일, 시, 분, 초
  - TIMESTAMP : ’2020-03-26 09:30:27’ 이런 식으로 연, 월, 일, 시, 분, 초 UTC(Coordinated Universal Time) 정보를 함께 저장한다.

* 문자열 타입(String type)
  - CHAR : 고정 길이 타입
  - VARCHAR : 가변 길이 타입
  - TEXT : 긴 문자열을 저장


### &#10045; 테이블 생성
~~~sql
-- 테이블 생성
-- AUTO_INCREMENT, PRIMARY KEY 설정
-- 백틱은 해당 단어가 identifier임을 나타내는 기호

CREATE TABLE `course_rating`. `student` (
	`id` INT NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(20) NULL,
    `student_number` INT NULL,
    `major` VARCHAR(15) NULL,
    `email` VARCHAR(50) NULL,
    `phone` VARCHAR(15) NULL,
    `admission_date` DATE NULL,
    PRIMARY KEY (`id`));
~~~

### &#10045; 테이블에 row 추가하기

~~~sql
-- 테이블의 row를 하나 추가
INSERT INTO course_rating.student
	(id, name, student_number, major, email, phone, admission_date)
    VALUES (1, '성태후', 20142947, '컴퓨터공학과', 'taehos@naver.com', '010-4728-3813', '2014-03-12');

-- 모든 부분에 값을 추가 한다면 컬럼 부분 생략해도 된다.
INSERT INTO course_rating.student
    VALUES (2, '성태후', 20142947, '컴퓨터공학과', 'taehos@naver.com', '010-4728-3813', '2014-03-12');
~~~

~~~sql
-- 특정 컬럼에 값을 추가 하기
-- 값을 추가하지 않는 다른 컬럼에는 null 값이 된다.
INSERT INTO course_rating.student 
	(id, name, student_number, major, admission_date)
	VALUES (4, '이현승', 20111025, '법학과', '2011-03-02');

-- id 값 AutoIncrement이기 때문에 값을 추가 해도 null 할당되지 않고 이전 row 보다 1 큰값 추가
INSERT INTO course_rating.student
	(name, student_number, major, admission_date)
    VALUES ('정유진', 20160843, '빅데이터학과', '2016-03-15');
~~~

### &#10045; 컬럼값 기존 값 기준으로 갱신하기

~~~sql
-- 갱신하기(WHERE 절이 중요하다)
UPDATE course_rating.student SET major = '멀티미디어학과' WHERE id =2;
~~~

~~~sql
-- id 기준으로 갱신하기
UPDATE final_exam_result SET score = 100 WHERE id = 1;
UPDATE final_exam_result SET score = 63 WHERE id = 2;
UPDATE final_exam_result SET score = 18 WHERE id = 3;

-- 기존값 활용하여 갱신하기
UPDATE final_exam_result SET score = score + 3 WHERE id = 1;
~~~

### &#10045; 데이터 삭제하기

~~~sql
-- 삭제 종류
-- 물리 삭제 : DELETE 문으로 값을 실제 삭제
DELETE FROM `order` WHERE id = 2; 

-- 논리 삭제 : 실제 삭제 하지 않고 삭제관련 컬럼을 UPDATE
UPDATE `order` SET is_cancelled = ‘Y’;

-- 둘다 장단점이 존재 하므로 두개를 혼용해서 사용한다.
-- 논리 삭제 이후 데이터 보유기간이 지나면 물리삭제
~~~

### &#10045; 컬럼 정보를 한 눈에 보여주는 DESCRIBE

~~~sql
-- 컬럼 정보를 보여줌
DESCRIBE student;
DESC student;
~~~

### &#10045; 컬럼 추가와 컬럼의 이름 변경

~~~sql
-- student 테이블에 gender 컬럼 추가 [컬럼 이름, 데이터 타입, 속성]
ALTER TABLE student ADD gender CHAR(1) NULL;

-- student 테이블에 컬럼 이름 변경
ALTER TABLE student 
	RENAME COLUMN student_number TO registration_number;
~~~


### &#10045; 컬럼 삭제와 데이터 타입 변경
~~~sql
-- 컬럼 삭제(DROP COLUMN)
ALTER TABLE student DROP COLUMN admission_date

-- 컬럼의 테이터 타입 변경(MODIFY)
-- major 컬럼값 정수값으로 변경 후에 컬럼 타입 변경
UPDATE student SET major = 8 WHERE id = 5;
UPDATE student SET major = 12 WHERE major = '멀티미디어학과';
UPDATE student SET major = 7 WHERE major = '법학과';
ALTER TABLE student MODIFY major INT;
~~~

### &#10045; 컬럼에 NOT NULL 속성 주기

~~~sql
-- 컬럼의 속성 변경하기 [컬럼이름, 데이터타입, 속성]
ALTER TABLE student MODIFY name VARCHAR(20) NOT NULL;
ALTER TABLE student MODIFY registration_number INT NOT NULL;
ALTER TABLE student MODIFY major INT NOT NULL;
~~~

### &#10045; 컬럼에 DEFAULT 속성 주기

~~~sql
-- 기본값을 설정하는 부분
-- 값이 할당되지 않을 때 기본 값이 들어감
ALTER TABLE student MODIFY major INT NOT NULL DEFAULT 101;
~~~

### &#10045; DATETIME, TIMESTAMP 타입의 컬럼에 값을 넣는 2가지 방식

* NOW() 함수 사용하기

~~~sql
-- 값을 삽입하기
INSERT INTO post (title, content, upload_time, recent_modified_time)
    VALUES ("기분좋은 날이에요", "오늘은 경주불국사에 갔어요", "파란하는과..", NOW(), NOW());

-- 값을 갱신하기
UPDATE post
    SET content = '오늘 제가 간 곳은 어디일까요?',
        recent_modified_time = NOW()
    WHERE id = 1;
~~~

* 컬럼에 DEFAULT CURRENT_TIMESTAMP / ON UPDATE CURRENT_TIMESTAMP 속성 설정하기

~~~sql
-- 컬럼의 속성을 변경하기
-- DEFAULT생성하면 INSERT시에 초기값 생성
-- ON UPDATE 속성 추가시 UPDATE 하면 초기값 갱신
ALTER TABLE post
    MODIFY upload_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    MODIFY recent_modified_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
~~~

### &#10045; 컬럼에 UNIQUE 속성 주기

~~~sql
-- 유니크 속성 설정하기
-- 유니크 속성 설정하기 위해서는 해당 컬럼의 값들이 고유한 값이 여야 한다.
-- DESCRIBE로 테이블 조회하면 Key 값이 UNI으로 변경된다.
ALTER TABLE course_rating.student MODIFY registration_number INT NOT NULL UNIQUE;

-- column 값이 중복되면은 추가할 수 없다.
-- 각 row마다 고유한 값을 가져야한다면 UNI 속성을 주자
INSERT INTO student (`name`, registration_number) VALUES ('최태웅', 20112405);
~~~

### &#10045; 테이블에 CONSTRAINT 걸기

~~~sql
-- 테이블에 이상한 ROW가 추가되는 것을 막아야 합니다.
-- 테이블에 CONSTRAINT를 적용해야한다.
-- st_rule 제약사항을 추가한다.
ALTER TABLE student
	ADD CONSTRAINT st_rule CHECK (registration_number < 30000000);

-- 제약사항 위반 조건 추가하기
-- 제약사항을 위반 하면 해당하는 값은 추가되지 않는다.
-- Error Code: 3819. Check constraint 'st_rule' is violated.
-- 여러개의 조건을 가는 것도 가능하다.
INSERT INTO student (name, registration_number)
	VALUES ('이대위', 30000000);
    
    
-- 제약사항 삭제
ALTER TABLE student DROP CONSTRAINT st_rule;

-- 두 개 이상의 제약사항 만들기
-- email 값안에 @ 존재, gender 값은 m, f 둘중하나
ALTER TABLE student
	ADD CONSTRAINT st_rule
    CHECK (email LIKE '%@%' AND gender IN ('m','f'));

-- 제약사항을 세심하게 걸수록 제대로된 데이터가 들어온다.    
INSERT INTO student (name, registration_number, email, gender)
	VALUES('김준성', '20130827', 'kjs@naver.com' , 'm');
~~~


### &#10045; 그밖의 컬럼 관련 작업들

* 컬럼 가장 앞으로 당기기

~~~sql
-- 컬럼 순서 컬럼 젤 앞으로 보내기
ALTER TABLE student
	MODIFY id INT NOT NULL AUTO_INCREMENT FIRST;
~~~

* 컬럼 간의 순서 바꾸기

~~~sql
-- 컬럼 간에 순서 바꾸기
-- gender 컬럼값 phone컬럼 뒤로 보내기
ALTER TABLE student
	MODIFY gender CHAR(1) NULL AFTER phone;
~~~

* 컬럼의 이름과 컬럼의 데이터 타입 및 속성 동시에 수정하기

~~~sql
-- 컬럼 이름 수정 RENAME COLUMN TO
-- 컬럼 타입 속성 수정 MODIFY
-- CHANGE를 사용하여서 둘다 동시에 가능
ALTER TABLE student
	CHANGE phone phone_num VARCHAR(20) NULL;
~~~

* 여러 작업 동시에 수행하기

~~~sql
-- name 컬럼의 이름을 rename으로 수정
-- email 컬럼의 타입을 VARCHAR(50) 속성을 NULL로 수정
-- gender 컬럼을 삭제
-- 새로운 컬럼 2개(height, weight) 추가
ALTER TABLE student
	RENAME COLUMN `name` TO `rename`,
    MODIFY email VARCHAR(50) NULL,
    DROP COLUMN gender,
    ADD COLUMN height DOUBLE NOT NULL,
    ADD COLUMN weight DOUBLE NOT NULL;
~~~

### &#10045; 테이블 이름 변경, 복사본 만들기, 삭제

~~~sql
-- 테이블이름 변경
RENAME TABLE student TO undergraduate;

-- 테이블 복사하는 방법 똑같은 구조의 테이블 만들기
-- 기존 테이블에 작업하기 힘들때에는 복사해서 테스트한다.
CREATE TABLE copy_of_undergraduate AS SELECT * FROM undergraduate;

-- 테이블 삭제하기
DROP TABLE copy_of_undergraduate;
~~~

### &#10045; 테이블 컬럼 구조만 복사하기

~~~sql
-- 테이블 구조만 복사하기(테이블안에 데이터는 없음)
CREATE TABLE copy_of_undergraduate LIKE undergraduate;

-- 테이블 구조만 있는데 값을 넣기
INSERT INTO copy_of_undergraduate SELECT * FROM undergraduate;

-- 데이터 값 삽이 쿼리문 활용(복사한 구조에 특정 row만 삽입 가능)
-- 이를 활용해서 원래테이블을 분할한 테이블로 만들수 있음
INSERT INTO copy_of_undergraduate SELECT * FROM undergraduate WHERE major = 101;
~~~


### &#10045; TRUNCATE으로 데이터 한 번에 날리기
~~~sql
-- 해당 TRUNCATE를 사용하면 테이터 값이 모두 날라간다.
TRUNCATE copy_of_undergraduate;
~~~


### &#10045; course 테이블과 review 테이블 만들기

~~~sql
-- course 테이블 만들기
CREATE TABLE course_rating.course (
	`id` INT NOT NULL AUTO_INCREMENT,
    `title` VARCHAR(30) NULL,
    `semester` VARCHAR(6) NULL,
    `maximum` INT NULL,
    `professor` VARCHAR(10) NULL,
    PRIMARY KEY(`id`)
);

-- review 테이블 만들기
CREATE TABLE course_rating.review (
	`id` INT NOT NULL AUTO_INCREMENT,
    `course_id` INT NULL,
    `star` INT NULL,
    `comment` VARCHAR(500) NULL,
    PRIMARY KEY(`id`)
);
~~~

### &#10045; Foreign Key 설정하기

~~~sql
-- Foreign Key 테이블 간의 참조 무결성을 지키기 위해 필요
-- Foreign Key 설정
-- Foreign Key 도 제약 사항
ALTER TABLE `course_rating`.`review` 
ADD CONSTRAINT `fk_review_table`
  FOREIGN KEY (`course_id`)
  REFERENCES `course_rating`.`course` (`id`)
  ON DELETE RESTRICT
  ON UPDATE RESTRICT;
  ~~~

### &#10045; SHOW CREATE TABLE 문으로 현재 테이블 어떻게 만들수 있는지 보기

~~~sql
-- SHOW를 통해서 CREATE TABLE 만들기
SHOW CREATE TABLE review;

-- 현재 만들어진 review 테이블 구조를 만드는 SQL문 입니다.
CREATE TABLE `review` (
  `id` int NOT NULL AUTO_INCREMENT,
  `course_id` int DEFAULT NULL,
  `star` int DEFAULT NULL,
  `comment` varchar(500) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_review_table` (`course_id`),
  CONSTRAINT `fk_review_table` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
~~~

### &#10045; Foreign Key로 보장되는 참조 무결성

~~~sql
-- 참조 무결성
-- 부모테이블에 없는 엉뚱한 값이 면 오류가 뜨면서 추가되지 않는다.
USE course_rating;
INSERT INTO review (course_id, star, comment)
	VALUES (8, 5, '정말 좋은 수업이에요!');
~~~

### &#10045; 부모테이블의 row가 삭제될 때 - RESTRICT 정책

~~~sql
-- RESTRICT 정책
-- 부모테이블 입장에서 생각, 자식테이블에 입장에서 생각
-- 부모테이블이 삭제되면 자식테이블 row 어떻게 처리되어야 할지?
-- ON DELETE RESTRICT 참조하고 있는 자식테이블이 있는 경우 부모테이블을 삭제하지 못한다.
-- 삭제하고 싶으면 자식테이블의 연관된 ROW를 모두 삭제한 후 에 가능하다.

USE course_rating;
DELETE FROM course WHERE id = 5;
-- Error Code: 1451. Cannot delete or update a parent row: a foreign key constraint fails (`course_rating`.`review`, CONSTRAINT `fk_review_table` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT)
~~~
- NO ACTION 정책은 RESTRICT 정책과 같은 정책이다.

### &#10045; 부모 테이블의 ROW가 삭제될 때 - CASCADE 정책

~~~sql
-- 현재 Foreign Key를 삭제하는 부분
ALTER TABLE `course_rating`.`review` 
DROP FOREIGN KEY `fk_review_table`;

-- 다시 Foreign Key를 추가하는 부분
-- Foregin Key를 다시 설정할때 원래 Foregin Key를 제거하고 다시 설정한다.
ALTER TABLE `course_rating`.`review` 
ADD CONSTRAINT `fk_review_table`
  FOREIGN KEY (`course_id`)
  REFERENCES `course_rating`.`course` (`id`)
  ON DELETE CASCADE
  ON UPDATE RESTRICT;
  
-- CASCADE : '폭포수처럼 떨어지다', '연쇄 작용을 일으키다'
-- 부모테이블의 ROW를 삭제할때 그것을 참조하고 있는 자식 테이블도 함께 삭제된다.
-- CASCADE 는 부모테이블을 삭제하면 자식테이블도 함께 삭제되므로 설정할때 명심하고 설정해야한다.
DELETE FROM course WHERE id = 5;
~~~

### &#10045; 부모 테이블의 ROW가 삭제될때 - SET NULL 정책

~~~sql
-- 현재의 Foreign Key 설정하는 제약 조건을 없애는 부분
ALTER TABLE `course_rating`.`review` 
DROP FOREIGN KEY `fk_review_table`;

-- 다시 Foregin Key 제약조건을 추가하는 부분
ALTER TABLE `course_rating`.`review` 
ADD CONSTRAINT `fk_review_table`
  FOREIGN KEY (`course_id`)
  REFERENCES `course_rating`.`course` (`id`)
  ON DELETE SET NULL
  ON UPDATE RESTRICT;
  
-- SET NULL일 때 부모테이블 ROW를 삭제한다면 자식테이블의 Foregin Key 값은 모두 Null로 변경
USE course_rating;
DELETE FROM course WHERE id = 2;
~~~

### &#10045; 부모 테이블의 row에서 참조당하는 컬럼이 갱신될 때는?

~~~sql
-- RESTRICT 문에서 값 갱신할 경우
-- 갱신 되지 않고 Error 메세지가 나온다.
UPDATE course SET id = 100 WHERE id =1;
-- Error Code: 1451. Cannot delete or update a parent row: 
-- a foreign key constraint fails (`course_rating`.`review`, CONSTRAINT `fk_review_table` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`) ON DELETE SET NULL ON UPDATE RESTRICT)

-- CASCADE 문에 값 갱신할 경우
-- 값이 잘 갱신되고 자식테이블에 있는 값 모두가 갱신된다.
USE course_rating;
UPDATE course SET id = 100 WHERE id =1;


-- SET NULL 문에 값을 갱신할 경우
-- 부모테이블은 잘 갱신 된다.
-- 자식테이블에서는 부모테이블을 참조하는 Foregin Key 값을 Null로 변경된다.
UPDATE course SET id = 200 WHERE id =100;
~~~

### &#10045; 논리적 Foreign Key, 물리적 Foregin Key

1. 성능 문제: DBMS에서 참조무결성을 한번 더 확인해줘야한다.
2. 레거시(Legacy) 데이터의 참조 무결성이 이미 깨진 상태라면 참조 무결성이 깨지더라도 데이터를 삭제하지 말자

- SHOW 문을 통해서 Foregin Key를 확인할 수 있다.

~~~sql
SHOW CREATE TABLE review;

-- 걸려져 있는 제약사항
CREATE TABLE `review` (
  `id` int NOT NULL AUTO_INCREMENT,
  `course_id` int DEFAULT NULL,
  `star` int DEFAULT NULL,
  `comment` varchar(500) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_review_table` (`course_id`),
  CONSTRAINT `fk_review_table` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`) ON DELETE SET NULL ON UPDATE SET NULL
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

-- 현재의 Foreign Key 설정하는  없애는 부분
-- 현재 설정된 fk_review_table 의 제약조건을 없앨 수 있다.
ALTER TABLE `course_rating`.`review` 
	DROP FOREIGN KEY `fk_review_table`;
~~~

### &#10045; 데이터베이스의 설계사항, 스키마
1. 개념적 스키마 : 하나의 조직, 하나의 기관, 하나의 서비스 등에서 필요로 하는 데이터 베이스 설계사항을 의미한
2. 물리적 스키마 : 데이터를 실제로 컴퓨터의 저장장치에 어떤 방식으로 저장할지 결정하는 스키마

### &#10045; 데이터 모델링
* 데이터를 어떻게 저장할 지 계획해야한다.
* 특정 이름과 데이터 타입을 결정해야 한다.
* 데이터 모델링 개념적 구조를 정하는 것 논리적 모델링
* 데이터베이스 구축에 필요한 걸 정하는 것 물리적 모델링
* 정리되지 않는 데이터를 인간이 이해할 수 있는 데이터로 정리하는 과정 데이터 모델링

### &#10045; Entity (개체)
- 저장하고 싶은 데이터의 대상
- 실제 대상 하나하나(ROW)
- Entity Type: 일반화한 Entity 종류(테이블)

### &#10045; Attribute (속성)
- Entity에 대해서 저장하려는 내용

### &#10045; Relationship (관계)
- Entity들 사이 연결점

### &#10045; Constraint (제약 조건)
- 각 데이터 간의 일정한 규칙

### &#10045; 데이터 모델링의 목적
- 저장하고자하는 데이터에서 Entity, Attribute, Relationship, Constraint 파악
- 데이터베이스를 구축할 때 기반이 될 모델 만들기

### &#10045; Relational 모델
- 테이블을 의미하는 수학적 표현
- Relationship : 테이블들 사이 맺어지는 관계
- 테이블 사이의 관계를 한눈에 알아보기 힘들다

### &#10045; Entity Relationship Model(ERM)
- ERM을 잘 파악하는 것이 중요하다.
- Entity 간의 관계에 대해서 나타 낼 수 있다.
- 선의 대해서 관계들의 특징을 나타낼 수 있다.
- 관계의 특징에 따라 모델링하는 방법이 바뀜

### &#10045; 데이터 모델 스펙트럼

* 개념 모델 : 추상적인 모델 Entity들과 Entity들 사이에 대략적인 관계
* 논리 모델(Logical Model) : 테이블 간의 관계를 간략적으로 나타낸 모델
* 물리 모델(Physical Model) : 실제로 데이터베이스를 구축할 수 있도록 나타낸 데이터 모델

### &#10045; 데이터 모델

1. 우리가 데이터를 저장하려고 하는 대상 : Entity(개체)
2. Entity에 대해서 저장하려고 하는 특징 : Attribute(속성)
3. Entity들 사이 생기는 연결점 : Relationship(관계)
4. 여러 데이터 요소들에 있는 규칙 : Constraint(제약 조건)

### &#10045; 좋은 데이터 베이스

* 나쁜 데이터 베이스
  - 데이터 중복저장, NULL이 많음
  - 연산 실행이 너무 오래 걸림
  - 원하는 정보를 찾을 수 없음
  - 틀린 데이터를 저장하고 있음

* 좋은 데이터 베이스
  - 중복, 틀린 데이터 없음
  - 빠르고 정확하게 데이터를 다룰 수 있음
  - 중복되는 데이터가 저장되지 않는다
  - NULL이 생기지 않는다
  - 데이터가 늘어날 때 테이블 구조가 변하지 않는다

### &#10045; 비즈니스 룰

* 특정 조직이 운영되기 위해 따라야 하는 정책, 절차, 원칙들에 대한 간단명료한 설명
  - 유저는 상품을 주문할 수 있다
  - 동일한 주문 내역은 한 번의 배달로, 3인안에 유저가 지정한 배송지에 전달돼야 한다. 만약 그렇지 못할 시, 유저에게 최대한 빨리 알려줘야한다.
  - 유저는 상품에 대한 평가를 줄 수 있다. 평가는 두 종류의 데이터: 1~5 사이 자연수의 별점, 그리고 200자 이내 줄 글을 통해 할수 있다.
  - 웹사이트면, 페이지에서 제공하는 모든 기능에 관한 규칙

### &#10045; Entity, Attribute, Relationship 후보 찾기

* 모든 명사는 entity 후보다
* 모든 동사는 relationship 후보다
* 하나의 값으로 표현할 수 있는 명사는 attribute 후보다
* attribute과 relationship들의 특성에 따라서 모델링이 바뀔 수 있다.

### &#10045; 여러 값을 갖는 Attribute

* 만약 여러개의 컬럼을 만들면 Null이 많아지고, 컬럼이 몇개 만들어야하는지 애매하다.
* 두개의 테이블과 Foregin Key로 설정하여 만들어야 한다.
* 하나의 값으로 표현되면 Attribute, 여러개의 값이면 Entity

### &#10045; 카디널리티(Cardinality)

* Entity type A와 B사이에서 A Entity 한개가 B Entity 몇개와 연결될 수 있고, B Entity 한개가 A Entity 몇개와 연결될 수 있는지
* 일대일, 일대다, 다대다
* 1:1(일대일)
  - 법적 부부관계
  - 주민등록증
* 1:N(일대다)
  - 유저의 평가(한명의 유저는 여러개의 평가)
  - 선생님과 수업의 관계
* N:N(다대다)
  - 쿠팡의 찜하기 기능
  - 학생과 수업의 관계

### &#10045; 카디널리티 ERM에서 표현하기

* 일대일, 일대다 관계에서는 Foregin Key 사용해서 만들어 줄수 있음
* 일대다 관계에서는 다에 해당하는 테이블에 Foregin Key를 추가한다.
* 다대다 관계에서는 두 Entity 만으로 표현할 수 없다. 연결 테이블(Junction Table)을 활용한다.
* 연결테이블은 두개의 일대다 관계를 통해서 모델링 할수 있다.


### &#10045; 데이터베이스 이상 현상

* 데이터베이스에서 삽입, 업데이트, 삭제를 제대로 할 수 없게 되는 경우
* 삽입 이상 : 새로운 데이터를 자연스럽게 저장할 수 없는 경우
* 업데이트 이상 : 데이터를 업데이트했을 때, 정확성을 지키기 어려워지는 경우
* 삭제 이상 : 원하는 데이터만 자연스럽게 삭제할 수 없는 경우
* 데이터 모델링을 제대로 하지 않았기 때문에 발생한다

### &#10045; 정규화(Normalization)

* 데이터베이스의 테이블이 잘 만들어졌는지 평가하고, 잘 만들지 못한 테이블을 고쳐나가는 과정
* 테이블을 정규형(normal form)이라고 불리는 형태에 부합하게 만들어나감
* 1NF, 2NF, 3NF
* 순서에 따라 규칙이 누적된다
* 데이터베이스에서 삽입, 업데이트, 삭제 이상을 없앨 수 있다
* 새로운 종류의 데이터를 추가할 때 테이블 구조 수정을 많이 하지 않아도 된다
* 데이터베이스 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있다
* 구현하기 전에 반영하는 것이 좋다

### &#10045; 1NF

* 테이블 안 모든 로우의 모든 컬럼 값들은 나눌 수 없는 단일 값이어야 한다
* 한 컬럼에 여러개의 값이 있으면 안된다.
* 한 컬럼에 여러개의 값이 있다면 컬럼 테이블을 만들고 Foregin key 로 저장한다

### &#10045; 함수 종속성(Functional Dependency)

* x의 값에 따라서 y의 이 결정될 때, y는 x에 함수 종속성이 있다고 한다
* name, age, gender는 email에 함수 종속성이 있다
* 이행적 함수 종속성 : 함수 종속성이 2번이상 있는 관계

### &#10045; Candidate Key

* 하나의 로우를 특정 지을 수 있는 attribute들의 최소 집합
* prime atttribute : Candidate key 포함된 column

### &#10045; 2NF

* 1NF에 부합해야 한다. (테이블 안 모든 값이 나눌 수 없는 단일 값이어야 한다)
* 테이블에 candidate key의 일부분에 대해서만 함수 종속성이 있는 non-prime attribute가 없어야 한다
* non-prime attribute 들을 적절한 테이블에 옮겨 주면 된다

### &#10045; 3NF

* 2NF에 부합해야 한다
* 테이블 안에 있는 모든 attribute 들은 오직 primary key에 대해서만 함수 종속성이 있어야 합니다
* 이행적 함수 종속성이 있으면 안된다
* 컬럼을 이동시킨 이후에 Foregin key를 만들어 준다

### &#10045; 비정규화

* 정규화를 하게되면 많은 테이블을 만들어야 되기 때문에 조인 연산을 많이 해야해서 시간이 오래걸린다.
* 성능 개선을 하기위해서 비정규화를 실행한다
* 비정규화는 주로 삽입, 업데이트, 삭제하는 것보다 조회하는 용도로만 사용하고 있을 대 사용한다

### &#10045; 네이밍(이름 짓기)

* 컴퓨터과학에서 어려운 건 딱 두가지가 있다 : 캐시 무효화와 네이밍이다
* 단수/복수 정하기


### &#10045; 데이터 타입

* 각 컬럼이 "어떤"데이터를 저장하는지에 대한 내용
* 데이터베이스의 가장 기본적인 제약 사항(데이터 정확성을 지켜주는 역할을 한다)
* 다양한 연산과 함수들을 사용하기 위해서
* 정수저장 단위(`TINYINT`(1BYTE), `SMALLINT`(2BYTE),`INTEGER`(4BYTE) ,`BIGINT`(8BYTE))
* 실수형 단위(`DECIMAL`, `FLOAT`, `DOUBLE`)
* 날짜 및 시간 타입(`DATA`, `DATETIME`, `TIMESTAMP`)
* 문자열 타입(`CHAR`, `VARCHAR`, `TEXT`)

### &#10045; 선형 VS 이진 탐색

* 뒤죽박죽 섞인 숫자 배열에서 2를 찾기 
* 처음부터 끝까지 찾는다. 선형탐색(Liner Search)
  
* 오름차순으로 저장된 배열
* 이진탐색법 사용 데이터가 정렬되어 있을 때 사용된다.
* 특정 순서대로 정렬 이진탐색을 통해서 빠르게 찾아낼 수 있다.


### &#10045; Clustered vs Non-Clustered 인덱스

* Clustered 인덱스
  - 테이블 자체를 특정 순서로 저장하는 인덱스
  - 조회 속도가 굉장히 빠르다
  - 인덱스를 하나밖에 못 만든다
  - 언어 사전과 비슷한 개념


* Non-Clustered 인덱스
  - 테이블 자체는 그대로 놔두고 다른 곳에 순서를 저장
  - 인덱스를 모든 컬럼에 대해서 만들 수 있다
  - Clustered 인덱스보다는 조금 느리다
  - 일반 책의 색인, 또는 인덱스와 비슷한 개념

* 인덱스
  - 특정 조건의 데이터를 찾는 조회를 굉장히 빠르게 할 수 있다
  - 그렇다고 해서 모든 컬럼과 모든 컬럼의 조합에 인덱스를 추가하지 않는다
  - 인덱스 업데이트 문제: 하나의 로우의 값을 바꾸면, 해당 컬럼이 포함된 모든 인덱스를 수정해야 한다
  - 인덱스를 추가하려는 테이블의 컬럼들이 얼마나 자주 삽입, 업데이트, 삭제되는지 파악
  - 이 연산들을 많이 해야되는 테이블의 컬럼들에는 인덱스가 오히려 역효과를 낳는다

* 인덱스 추가 기본 원칙
  - 모든 primary key에 대해서 인덱스를 만들어준다
  - 모든 foreign key에 대해서 인덱스를 만들어준다
  - 특정 조회 쿼리가 너무 느려지거나, 느려질 게 확실한 경우 조회에 사용되는 컬럼들에 대해서 인덱스를 만들어준다























    






